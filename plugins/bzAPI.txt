//*****************************************************************************
//***                             bzAPI.txt                                 ***
//***                    Plug-in development for BZFlag                     ***
//*****************************************************************************


* This document:

This document is a description of the bzflag plug-in system and it's associated
API. It will atempt to explain how to make a plug-in, what you can do in a
plug-in and what the basic API features are.

* What is a plug-in

A plug-in is a compiled code module that is loadable at runtime by the BZFlag
game server (bzfs) that can change the way that the server runs. Since plug-ins
are compiled Plug-ins need to be built on the platform they are to be run with.
This means that a plug-in built for windows will not work on linux, and vice/
versa. Plug-ins are writen in C++ as Dynamic Librarys, ether as a DLL on windows
or a .so file on linux/OS X.

* What can a plug-in do.

Plugins can install event handlers for a number of events in bzfs. Events are
actions that happen in the game, such as the capture of a team flag, or the death
of a player. Plug-ins can then call API functions that can change the gamestate
in response to the event, such as sending a text message, activating a world
weapon, or kicking a player. All plug-in actions are event driven. A plugin is
allways called first by the server in response to an action.

* What do I need to make a plug-in, and what do I need to know.

To make a plug-in you will need to know at least C and should be familar with
the C++ language. Many of the API calls and structures will use C++, but they 
can be called in a C "style" if you wish. Since plug-ins are compiled code you
will need a compiler for your OS and the knowledge of how to use it. The sample
plugin has makefiles and Windows VC projects that you can use as a basis. You
will also need the bzflag source code so that your code can have access to the
functions that bzfs provides ( bzfsAPI.h ).



//****************** plug-in entry points  ************************************

There are 2 primary entry points into the plug-in. These are the 2 core
functions that the plugin must implement. These are defined as such;

BZF_PLUGIN_CALL int bz_Load ( const char* command );
BZF_PLUGIN_CALL int bz_Unload ( void );

bz_Load is called when the plug-in is first initialized. This is when the plug-in
should register any event handlers that it wishes to use and initialize any "one
time" startup data.

bz_Unload is called when a plug-in is no longer needed and will be shut down. This
is most commonly called when bzfs is quiting. A plug-in should do any clean up
in this callback.

Both functions should be proceded with the BZF_PLUGIN_CALL macro. This 
macro will tell your compiler to export these functions so bzfs can call them.


These will be the only 2 functions called by bzfs for non event actions.


//****************** registering event handlers  *****************************

A plugin is basically useless if it can't react to events in game. To allow this
a plugin needs to tell bzfs that it would like to listen for events. To do that
the plugin will need to call the following function;

bool bz_registerEvent ( bz_teEventType eventType, int team,
                        bz_EventHandler* eventHandler );

where eventType is one of the following enumerations;

	bz_eCaptureEvent        // flag is captured in a CTF game
	bz_ePlayerDieEvent      // a player gets killed
	bz_ePlayerSpawnEvent    // a player joins as a tank
	bz_eZoneEntryEvent      // a player enters a zone ( not implemented )
	bz_eZoneExitEvent       // a player exits a zone ( not implemented )
	bz_ePlayerJoinEvent     // a user joins the server ( player or observer )
	bz_ePlayerPartEvent     // a user leaves the server ( player or observer )
	bz_eChatMessageEvent    // a chat message is sent 
              bz_eUnknownSlashCommand // a "/" command was issued but not handled
	bz_eGetPlayerSpawnPosEvent // the server needs a spawn posttion for a player.

team is an integer that defines a team filter for the event. The value of; BZ_ALL_USERS indicates
that the event will be called every time it happens, regardless of team.

eventHandler is a pointer to a event handler class. Plug-ins should derive their own versions
of the event handler class from bz_EventHandler and pass this pointer into the function.
When the event happens the process function of the class will be called so that the plugin can
perform any actions it desires.

When the plug-ins unload function is called. The plug-in must remove any events it has loaded
by calling

bool bz_removeEvent ( bz_teEventType eventType, int team,
                        bz_EventHandler* eventHandler );

Failure to do so may cause crashes if the plug-in is manualy unloaded at run time.


Event Handlers;

The event handler is a pure virtual class. It does not perform any logic or actions, but simply
provides a framework for a plugin to use. You need to derive your own version of an event
handler before you can use it, providing your own code in the "process" method.

virtual void process ( bz_EventData *eventData );

When the process method is called, the eventData will be a pointer to a data class. There 
are a number of different data classes all derived from bz_EventData. The eventType member
of the base class will tell you what type the data is. This allows for the same handler to be used
for more then one type of event.

The event data for event types are as follows, along with there associated data items.
Some events may share event data types

bz_eCaptureEvent
bz_CTFCaptureEventData
{
	int 	teamCaped;		// the team that had there flag captured
	int		teamCaping;		// the team that did the capturing
	int		playerCaping;	// the player ID who did the capture
	float 	pos[3];			// the last known position of the player
	float	rot;			// the last known angle of the player
	double	time;			// the time in seconds of the event
}

bz_ePlayerDieEvent
bz_PlayerDieEventData
{
	int			playerID;			// the ID of the player who died
	int			teamID;				// the team of the player who died
	int			killerID;			// the ID of the player doing the killing
	int			killerTeamID;		// the team of the killer
	std::string flagKilledWith;		// the flag the killer had when killing
	float		pos[3];				// the last known position of the victim
	float		rot;				// the last known rotation of the victim
	double		time;				// the time of the death
}


bz_ePlayerSpawnEvent
bz_PlayerSpawnEventData
{
	int playerID					// the ID of the player that has spawned;
	int teamID;						// the Team the player just spawned to
	float pos[3];					// the position of the spawn
	float rot;						// the rotation of the spawn
	double time;					// the time of the spawn
}

bz_ePlayerJoinEvent AND bz_ePlayerPartEvent
bz_PlayerJoinPartEventData()
{
	int playerID;					// the ID of the user that has joined or parted
	int teamID;						// the team ID of the user
	std::string callsign;			// the callsign used by the user
	std::string reason;				// if a part event, the reason for the part
	double time;					// the time of the event
}

bz_eChatMessageEvent
bz_ChatEventData
{
	int from;						// the player ID of who the message is from
	int to;							// the player ID of who the message is for
	std::string message;			// the message
	double time;					// the time of the message
}

bz_eUnknownSlashCommand
bz_UnknownSlashCommandEventData
{
	int from;						// the player ID of who the message is from
	bool handled;					// flag that tells if the command was handled.
									// if the plugin handles this command it must
									// set this value to true before it returns
	std::string message;			// the message
	double time;					// the time of the message
}

bz_eGetPlayerSpawnPosEvent
bz_GetPlayerSpawnPosEventData(
{
	int playeID;					// the player ID of who needs to be spawned
	int teamID;						// the players team
	bool handled;					// flag that tells the plugin if the command
									// has allready been handled.
									// if the plugin handles this command
									// it must set this value to true on return
	float pos[3];					// the proposed spawn position
	float rot;						// the proposed spawn rotation
	double time;					// the time of the request
}

//****************** calling bzfs functions  *****************************

Once you have your event in place, you need to do something with all this
data. To handle this the API provides a number of functions that can be
called directly. These functions will perform actions and return data about
the current game state.

The functions are as follows;


BZF_API bool bz_getPlayerByIndex ( int index, bz_PlayerRecord *playerRecord );
This function will take a player index, and fill out the passed in player data
class.

The player data class contains the following data;

bz_PlayerRecord
{
	int playerID;							// id of the player
	std::string callsign;					// callsign the player is using
	int team;								// team 

	float pos[3];							// last known position
	float rot;								// last known heading

	std::string ipAddress;					// the network address for this connection
	
	std::string currentFlag;				// the flag the user presently has
	std::vector<std::string> flagHistory;	// a list of all flags the user has had

	bool spawned;							// true if the user is in game as a tank
	bool verified;							// true if the user has been authenticated
											// ether global or local
	bool globalUser;						// true if the user was verified from the
											// global login system
	bool admin;								// true if the user is an admin
	std::vector<std::string> groups;		// a list of all the groups the user is a member of.
}

bz_PlayerRecord also contains an update() method. This is used to update the data for the player
that may change, like groups, last known state, etc...

BZF_API bool bz_updatePlayerData ( bz_PlayerRecord *playerRecord );
Updates a playerRecord to it's current data. This is the same as calling
update on the bz_PlayerRecord class.


BZF_API bool bz_sendTextMessage (int from, int to, const char* message);
Sends a text message to the specifid user. BZ_SERVER should be used for
messages from the server. BZ_ALL_USERS for a to user will send the message
to all connected users.

BZF_API bool bz_fireWorldWep ( std::string flagType, float lifetime, 
								int fromPlayer, float *pos, float tilt,
								float direction, int shotID , float dt )
Adds a shot to the world of the specified type with the specified paramaters.
BZ_SERVER should be used as the fromPlayer for normal world weapons.

BZF_API double bz_getCurrentTime ( void );
Returns the current server time in seconds ( time server has been alive ).

BZF_API double bz_getBZDBDouble ( const char* variable );
Querys the BZDB database for the specified value and returns it as a double;

BZF_API void bz_debugMessage ( int debugLevel, const char* message );
Outputs the specified message if the current debug level is at least the
specified level.

BZF_API bool bz_kickUser ( int playerIndex, const char* reason, bool notify )
Removes the specified user from the server.

BZF_API bool bz_IPBanUser ( int playerIndex, const char* ip, int time, const char* reason )
Adds an entry to the main banlist with the specified data.

BZF_API bool bz_getStandardSpawn ( int playeID, float pos[3], float *rot );
Returns a normal spawn position for the specified user.


//****************** custom slash commands *****************************
A plug-in can register a special handler for a custom / command. This allows
a plug-in to handle commands easyer then hooking into the UnknownSlashCommand
Event.

Similar to other events, custom slash commands provide a pointer to a handler
class that the plugin overides using the function.

BZF_API bool bz_registerCustomSlashCommand ( const char* command, bz_CustomSlashCommandHandler *handler );


the handler pointer is to a class that has been derived from bz_CustomSlashCommandHandler

class bz_CustomSlashCommandHandler
{
public:
	virtual ~bz_CustomSlashCommandHandler(){};
	virtual bool handle ( int playerID, std::string command, std::string message ) = 0;
};

When a player issues the command, the handler will have it's handle method called.
And it can then do what ever it needs.

when a command is no longer needed it can be removed with.
BZF_API bool bz_removeCustomSlashCommand ( const char* command );

Only one custom slash command can be installed at a time.


//****************** examples *****************************

    get some

