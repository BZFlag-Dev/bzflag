Information for the BZFlag Developer
====================================

BZFlag source code lives in the following directories:

game independent, platform independent libraries
------------------------------------------------
common		- general utility
geometry	- geometric mathematics
obstacle	- collision detection
scene		- scene graph
ogl		- wrapper classes for OpenGL

game independent, platform dependent libraries
----------------------------------------------
net		- networking
platform	- general platform dependant code

applications
------------
bzflag		-- the BZFlag client
bzfls		-- the BZFlag meta-server (i.e. the list of servers server)
bzfs		-- the BZFlag server
bzfrelay	-- the BZFlag relay (for relaying to servers)

Note that only a few directories contain code directly related to the game
BZFlag.  In particular: bzflag, bzfls, and bzfs. (And obstacle, but that will
hopefully be made more general some day.) The rest of the code could
potentially be used in a different game. If your code is BZFlag specific then
it should go into one of the above directories (game if used by more than one
app, otherwise into the appropriate app directory).  If not then put it in one
of the other directories or add a new directory.


Coding conventions
==================

If you plan on contributing any source code to BZFlag, we would like you to
follow these conventions.  Contributions that don't conform are likely to be
rejected until they do.

Code Organization
-----------------
Follow the above organization when introducing new files.  Any code that would
potentially be useful in another game goes outside of the app directories and
outside the game directory.  Platform dependent code normally goes into
platform, net.

Header files that are private to a library go into that library's directory.
Header files exported from a library go into the include off the top-level.
Header files for classes introduced in an application directory should never go
into include.

C++ features
------------
Earlier versions of BZFlag avoided certain features of C++ that have matured
enough to be widely and well supported.  These features are now permitted and
encouraged:
  bool			-- the boolean type and True and False are gone
  standard C++ library	-- use where appropriate (AList is gone)
  templates		-- use where appropriate
  exceptions		-- use where appropriate

These should still be avoided:
  run-time typing	-- if you find yourself needing RTTI, its often a
			   sign of bad design. try to find another way to
			   implement your idea.

Multiple inheritance is strongly discouraged unless in the Java style of single
implementation inheritance and multiple interface inheritance.  Multiple
inheritance otherwise can quickly lead to very hard to understand code.

Formatting
----------
Everybody has their own style and has things they don't like about any other
style.  Well we can't have a zillion styles in the code. So follow the BZFlag
if you want your contribution included.  The source code serves for examples
but some rules:

  1)  indents are 2 characters. Tabs are 8 characters. There are vi setting in
      each file to adopt this convention, suggestions welcome here for setting
      up other environments.
  2)  the opening brace of all blocks goes on the same line as the statement
      introducing it except for functions where it goes on the following line.
      the closing brace is indented like the statement except for functions
      where it aligns with the open brace.  for example:
        void foo()
        {
          for (;;) {
            if (expr) {
            }
          }
        }
  3)  an else clause goes on the same line (there are many bad examples):
        if (expr) {
        } else {
        }
	*note that old code had the else on the next line,
	 please clean this up wherever you may find it*
  4)  if *either* the if block or else block requires brackets then they both
      get brackets.  if neither require brackets then use brackets on both or
      neither at your discretion.
  5)  when using `delete' or `delete[]' don't bother to test the pointer if
      it's NULL first.  use new and delete rather than malloc and free.
  6)  data members should be usually private unless making plain old data.
      separate methods from data in class definitions with (possibly redundant)
      access specifiers.  public c'tors/d'tors should be first, followed by
      public member functions, protected member functions, private member
      functions, and data members.
  7)  macro names are all capitals, class names have the first letter of each
      word capitalized, all other names have the first letter of each word
      except the first capitalized.  only macros may use underscores except a
      leading underscore in a method parameter name is allowed to make it
      different from a member variable.
        #define FOO bar
        class MyClass {
        public:
            void        addStuff(int addMe, int _y) { y = addMe + y; }

        private:
            int         y;
        };
  8)  put spaces after statements followed by expressions and spaces around
      operators.  for example:
        if (a == b)
      not
        if(a==b)
  9)  Do not leave old commented code hanging around and do not submit patches
      with "// Added by foo on xx" comments. This is what version control
      software is for.

Violations of these rules in the existing code are not excuses to follow suit.
Non-conformant code may be fixed.  Patches to non-conformant code should follow
the non-conformant code's style if following the rules would cause an ugly
mess.


Sounds
======
Sounds are stored as 22.050KHz WAV files. We will likely move to OGG.


Images
======
Images are stored as .png (portable network graphics format). Compression,
but no additional options such as interlacing.


BZDB
====
BZDB is the generic name:value pair database within bzflag and bzfs. Its useful
for data that can be serialized to a string that needs to be accessible to
many areas of the code. It also provides facilities for saving persistant
pairs to the config file and downloading variables from the server.

BZDB is not an object broker, and isn't meant to be. If you have data within an
object that needs to be accessible from a number of places, but don't want to
pass the object around, you could store that data within BZDB (if accessed
often, such as game variables like gravity, you will need a cached version
anyway to avoid the overhead of lookup). Using BZDB adds unnecessary overhead
if objects generally keep their data hidden without needing persistant state.

Basically, if your data can be serialized to a string, and it makes sense to do
so (eg: config file option, game variable downloaded from server), use BZDB. If
you wanted an object broker, use a freakin' global.


Details -- common
=================
common.h	-- basic types and function declarations
ErrorHandler	-- a central place for printing errors (using printError())
TimeBomb	-- used for expiring development releases

Details -- geometry
===================
Intersect	-- 2D and 3D intersection functions
Ray		-- a 3D ray
ViewFrustum	-- a 3D viewing frustum

Details -- net
==============
Contains stuff for network handling.  This is in flux.  All platform specific
network code should end up in here.

Details -- obstacle
===================
Collision detection stuff.  Currently specific to BZFlag it handles boxes,
pyramids, teleporters, etc.  This should be rewritten to do generic 3D
collision detection on, at least, convex polyhedra.  It should also do
collision response.

Details -- ogl
==============
Wraps rendering state, texture maps, and texture fonts.  Currently it is OpenGL
specific but it could be made rendering library agnostic. There are a number of
places outside this library where OpenGL is used, though.  Ideally all
rendering library calls would go through a library agnostic interface.
However, OpenGL has the widest support of any rendering library so this is
pretty much a non-issue (unless someone wants to port to a game console).

Details -- platform
===================
Contains files to implement platform dependent versions of:
  BzfDisplay	-- event handling, screen size, and video format changing
  BzfVisual	-- wraps pixel format selection
  BzfWindow	-- window management, gamma control, mouse & joystick stuff
which handles:
  configuration file I/O
  text console output
  time and timers
  querying the user name
  environment variables
  signal handling
Configuration files are platform independent but their location is not.

Details -- scene
================
FIXME

Details -- mediafile
====================
Contains loaders for image and sound files

Details -- zlib
===============
zlib compression library for PNG decompression
