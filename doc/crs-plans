world files
===========
worlds must become more configurable.  there are several types of
things that go into a world:

  * obstacles
    * collision detection only against these
    * convex polyhedra
    * special uses
      * may not have associated visible geometry
      * can specify zones
        * world volume
        * team base zones
        * teleportation zones
        * tank restart zones
        * flag insertion zones
  * models
    * background objects (clouds, stars, etc)
    * the static objects (typically the obstacles)
    * dynamic objects
      * tanks
        * possibly with user customizable areas
      * flags
        * possibly per-type
      * explosions
      * shots (per-type)
  * server options
    * game style (CTF, etc.)
    * number of players per team
    * flag counts
    * player velocities
    * shot speeds, lifetimes, etc.
    * gravity
    * etc

note the separation of visible geometry from collision detection
geometry.  this allows separation of the collision detection and
response engine from the rendering engine.  and it permits use
of the collision engine for tasks other than preventing tanks
from driving through buildings.

normal obstacles, like buildings, will have visible geometry that
exactly (or closely) matches the collision volume.  visible
detail can be left out of the collision volume for efficiency or
special effects and collision volumes can be left out of visible
geometry for a hologram-like facade.

visible geometry, hereafter called models, describe what the
user sees.  first, we have the distant background objects (e.g.
stars, mountains, the sun and moon).  then there are the buildings
and other objects that don't move (at least not interactively).
and then there are the dynamic objects models, like tanks and
shots.

the client should get *all* models from the server (unless the
model is cached locally).  this allows a server operator to
completely define the look of the game.  and it should mean no
changes to the code (either client or server) are necessary to
adjust the playing field.  the one exception to this would be
user customizable logos and such.  these would be uploaded to
the server and sent to the other players so we can slap our
mark on the side of our tank.

the model format is already established and the world file should
reference model files or include models inline to define visible
geometry.  simple name/value pairs should handle the server
options satisfactorily.  we'll just need to choose what those
options are.  and we'll need an obstacle format.

the obstacle format interacts with the model format since many
obstacles have corresponding models.  to me this suggests that
the model and obstacle formats may actually be the same thing.
we just need to define an obstacle node for the model format (and
scene graph) and it can use the existing transformation and
geometry nodes.

some things don't make sense on an obstacle.  some, like color,
can just be ignored.  others, like billboard, could potentially
have some meaning but don't have to for now.  and others might
be useful immediately, like animation.  we'll need to make some
choices.

one consequence of this design is that an obstacle, say a box,
is not defined by specifying the position, rotation, etc.
directly on the box.  instead you specify the transformation
to apply to a generic box using a transformation node.  so,
for example, instead of:

  <box pos="1 1 0" rotation="45">

you say

  <transform>
    <translate>1 1 0</translate>
    <rotate>0 0 1 45</rotate>
    <ref id="box">
  </transform>

where there has been a "box" defined previously.  (any node in a
scene graph can have a name associated with it and that node and
all its descendants can be instantiated using <ref>.)  yes, it's
more wordy, but i think it's more flexible.  and it means you
don't have to mess with the code to add a new "box" type or
somehow define what the parameters to <box> mean.  the current
box, pyramid, teleporter, and base models would become part of
the standard install.  they would include both visible and
collision geometry.


server interaction
==================
we need a few messages in the protocol for the following:

  * client to server command
  * server to client command
  * command output (client to server or server to client)

the server can use commands to modify the database, among other
things, to control the user's client.  this includes changing
the client's top speed or turn rate, the time of day, etc.

the client can use commands to query the server or, with proper
authentication, control the server.  it might also be how a
client broadcasts a message to other players:  the client sends
the server a command to broadcast a message (or send it to a
particular player or group of players).  this would replace
the leading / hack for sending server commands.


reduction of cheating
=====================
the server should take on more responsibility for tracking
gameplay so it can detect and respond to cheating.  this includes
ensuring that players don't exceed their legitimate speeds and
respect obstacles.

the server can do automatic flag grabs so clients need never send
a grab request.  this will incidentally fix a bug where a client
sends a rapid stream of flag grab requests when over a flag.

the server can also do the hit detection for shots.  this prevents
trivial hacks to avoid getting killed.  since the server knows a
player was killed, a client can't be hacked to avoid losing points
or pretend to have not died.


community
=========
there should be more support for communication before, during, and
after a game.  first, we should allow observers.  they can watch a
game in progress and roam around but cannot communicate with
active players.  (if we add a game style where each player gets
some number of lives then players that have used them all up can
become observers and talk to the other observers.)

there should be a chat room where players can gather on a server
without starting play.  they can decide on teams and gamestyle and
start playing, or they can just hang out and watch a game.  there
should also be a "green room" where players gather and, when all
players are connected, the game starts.  each team gets its own
room but can see who is in the other rooms.

users should be able to send private messages to other specific
users and form new rooms, optionally accessible by invitation only.  

it'd be very cool if users could download game logs for replay.  or
make rooms where the server replays a game with VCR controls so
people can discuss situations.


game styles
===========
i'd like to see options for new game styles:

  * capture territory
    * cell by cell
    * reversi-like
    * go-like
  * capture N flags limit
  * collect N tokens (generalizes the above)
  * last man standing (LMS), each player gets N lives

some flags need review:

  * PZ -- consider for removal
  * SR -- consider for removal
  * IB -- consider for removal
  * MG -- consider for removal
  * G  -- consider limits, like N seconds or N shots
  * GM -- consider limits, like N seconds or N shots
  * L  -- consider limits, like N seconds or N shots
  * SH -- consider shielding up to N hits (instead of 1)



crs's personal development notes
================================
i thought i'd include a list of my own notes here until v1.8 is
farther along so everybody can see what i've got in mind.  these
aren't really organized or anything.

newly missing things:
  animations
    flag waving
    flares from guided missile
  flag warp
  grid lines on ground (can probably drop these)
  tank parts to fly off independently
    put in model files as animated transforms
  dynamic lighting
    don't want to mesh anymore
    maybe use texture mapping to add extra illumination
    things that illuminate: shots (not L or SW), explosions
  shadows
  render options no longer have an effect (except smooth on radar)
    must be able to force certain features off
  debug rendering
  LOD on tank models (models are there but LOD node is not)
  keyboard motion
  roaming, freezing, snapping
  console scrolling
  OO building insides
  IDL crossing teleporter
  clipping when crossing teleporter
  need material properties in geometry

newly wrong things:
  no workarounds for busted graphics cards
  missing cracks when dead
  seam in mountains due west
  crashing when loading a model with invalid syntax
  billboard is too specific, make it general purpose
  not XML:
    must have space before />
    all attributes must be in double quotes
    # is not a comment (use <!-- and -->)
  must prevent buffer overflow in BzfString::vformat!
  team bases are now lighted

dynamic gstate sorting?
  should be able to choose items to sort on and in what order
  should be able to auto-detect a good set of sort items

color should be unsigned byte RGBA
  use dirty flag and compile into unsigned byte RGBA as necessary
  possibly better performance on some drivers

noise texture not getting rendered in radar when jammed

dynamic change of views works but:
  should warp mouse when it changes
  crosshair display should be a view?
    crosshair could then be in boths views in stereo

OpenGL context stuff only works with one context.  clean it up.
  context should probably be shared if possible

should merge readers?
  put menu and view in same file
  maybe models too

views and menus should be able to map font names to files

need a text primitive
  allow a "stringindex" field.  just fills in the index field using
  the codes for each character in the string.  a text primitive will
  also need a current font.  that probably goes in gstate but it
  conflicts with texture.  could force texture to font's texture.
  that should get everything setup right.  may want text alignment
  options in gstates.

pull robot stuff out of app?
  put files into a separate place for now
  put functions into new files in the separate place

switch everything (except model files) to radians?

check teleporter dimensions

ViewItemMessages:
  cache word breaks
  must be able to detect changes to message buffer and view item size/state

should be able to get more values via BZDB
  OpenGL strings: set the values when OpenGL context is bound
  bzflag version
  bzflag author, maintainer
  bzflag expire time

break fonts into image file and glyph info
  could put glyph info into XML file or leave binary
  add max texture filter setting to font texture
  add tools for manipulating/creating fonts to tree

generalize sound library and move to game independent section

not handling full light source info in SceneVisitorRender

edit control doesn't scroll horizontally

should have compose history in message buffer

should allow interior editing in edit control and message compose

derive all SceneVisitorRender types from a single base class

replace SGI image format with BMP files?

in bzgview search for lights
  enable one automatically if none found and there are normals

move path manipulation stuff to platform from FileManager.cxx

centralize flag handling and make it generic
  want to touch fewest places possible when adding flags

move VERSION from makefiles/project files into global.h
  version is game dependent
  it's a pain to keep the makefiles and project files in sync

server should be doing more work to prevent cheating
  server should track and verify legitimacy of:
    player motion
      linear and angular velocity
      obstacle collision (or non-collision)
      teleporters complicate this
    shots
      speed
      frequency
  server should probably do kill checks
    client still dies and loses points even on hacked client
  server can automatically do flag grabs

add messages so server can get/set database entries
  use locked DB entries for:
    maximum speed and turn rate
    max number of shots
    gravity
    jump velocity
    world size
    force latitude/longitude/time of day
    current flag?
  allows dynamic changing of game parameters

sending messages:
  should be able to encrypt messages and broadcast to all players.
  only those players with correct key can decrypt them.  (messages
  begin with recognizable sequence to squelch messages that can't
  be decrypted correctly, though this provides known crypttext.)
  this allows people to positively identify themselves to others.
  could also use this with server to reserve call signs.

use std c++ streams
  drop all uses of FILE* (almost done)

make 3D library agnostic versions of OpenGL*
  derive OpenGL versions from these
  find other OpenGL-isms and make generic
  ultimately, put all OpenGL calls into GState or object wrappers

star data:
  current star data has 400 stars without color info.  color would be nice.
  http://adc.gsfc.nasa.gov/adc-cgi/cat.pl?/catalogs/5/5050/

future server world download:
  download obstacles
  download models
  download world scene (or include as a named model)
  get dynamic objects from server
    insert players
    insert flags
    insert shots
  server must track changes since player started downloading dynamic objects
   and send those until player is up-to-date
   easiest to simply queue updates to send after dynamic objects

note:  world scene should use a few geometry and primitive nodes as possible
  performance is much worse with lots of geometry nodes and/or primitives
