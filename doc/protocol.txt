BZFlag network protocol
-----------------------
[ This is a work in progress. ]

This is a draft of the not-yet-implemented protocol for versions 1.8+
look for "FIXME" items to see what may still change.

status
------

Tim Riker <Tim@Rikers.org> is working on this. Some open items:

* position, velocity, azimuth, time were all floats, they have been changed to
ints. Bounds will have to be considered, times for flag motion etc will likely
be milliseconds where as remaining game time would likely be seconds? 16 bit
values would be preferred.

* world format has been removed. an XML format should be devised.

* player ids are now in lockstep on server and all clients.

* special player numbers. 0 = server, 255 = everyone, 254 = invalid 253 = rogue team,
249-252 = colored teams, 1-maxplayers = normal players. Note that maxplayers in
this context includes observers as well as proper players.

* should msgtype just be a u8 ? the 2 char format is not very useful if the
rest is binary.

* what about flag id? there would still be a short name here, but it does not
need to be in the protocol and hence could be a few letters longer if needed.

* MsgCaptureFlag is gone as MsgDropFlag now has a reason.

* MsgShotEnd is implied by a MsgKilled so MsgShotEnd only happens for GM like
shots.

* Flag types could be set to NoFlag until a client grabs them. This would mean
that when a client picks up identify it gets an update for every flag that is
on the ground and any that are dropped while he has the flag. The client could
send MsgFlagUpdate queries for any flags that are in range that it has not asked
about before. Probably more complication than value.

layers
------

This document currently only covers the msg format. These messages are
then combined into larger udp frames. Packets that are "reliable" need to
be marked as such. Packets that are not "reliable" may be dropped by the lower
level transport. "reliable" packets will get there, but may not get there in order.

direction
---------

--> means from client to server
<-- means from server to client

All multi-byte data is in network byte order (aka big endian);  that is, the most
significant byte comes first followed by successively less significant bytes.

All numbers are integers unless otherwise specified.  Integers can be 8, 16, or 32
bit signed 2's compliment or unsigned (encoding is the same in regardless of signed
status).  Values in this document in byte boxes are given in hexadecimal.  Values
in the text are given in decimal unless otherwise noted.

Bitfields are encoded as unsigned integers.

Multibyte values are *not* necessarily aligned on 2 or 4 byte boundaries.

A client normally follows the following sequence during game play:

	connect to server
	get the world description including world resource md5 tag
	recursively get any resources that are not cached
	join the game
	send/receive game messages
	leave game
	disconnect from server


common message structures
-------------------------
Most messages begin with the length of the message in bytes followed by a 16
bit code. The length is 16 bits and excludes itself and the code, so it's the
actual length of the message minus 4.

Flag status is common to a few message types:

	u16 flag num
	u16 flag id
	u8 status
	u8 player id
	u32 position x
	u32 position y
	u32 position z

`status' gives the current location of the flag:
	FlagNoExist  -- not active (i.e. not in the game)
	FlagOnGround -- sitting on the ground ready to get picked up
	FlagOnTank   -- on a player's tank
	FlagInAir    -- in the air and will fall back down
	FlagComing   -- appeared and is falling to the ground
	FlagGoing    -- was thrown in the air and is disappearing

`Player id' indicates which player has the flag when `status' is FlagOnTank.  It
isn't used for any other status.

`Position' is the location of the flag on the ground. It is actual only when
`status' is FlagOnGround. The position of a flag when on a tank is the position
of the tank (centered on and at the top of the tank) When a drop is given, the
position is where the flag should be when it lands, and location of the
previous player is where the flag is moving from. When a vlag is coming, the
position is the landing location. When a flag is leaving the launch point
should be determined by the previous position.


connect to server
-----------------
  -->   connect(server port)
  -->   FIXME client version, desired player type, supported flags, etc
  <--   FIXME server version and info, player id, and whether player can join

Server and client should verify the version.  Major version numbers indicate
incompatible protocol changes.  Minor versions indicate enhangements which the
client should be able to cope with. Different revisions of a given version are
compatible and usually just indicate client user interface changes.

PlayerID here is a connection tracker for the server. If the server has no
slots open it will just MsgSuperKill


message super kill
------------------
  <--   MsgSuperKill
	u16 length = 0
	u16 0x736b

This message can be sent by the server at any time. The client should assume
the server is unreachable and not send any more messages.


getting the world
-----------------
  -->   MsgGetWorld
	u16 length = 2
	u16 0x6777
  <--   MsgGetWorld
	u16 length
	u16 0x6777
	u16 style bitmap
	u16 max players (includes observers)
	u16 max shots per player
	u16 max number of flags (includes team flags)
	u32 linear acceleration
	u32 angular acceleration
	u26 bad flag shake time 
	u32 bad flag shake win count
	u32 server time
	... world model name

Client sends MsgGetWorld requests until it has read the world description. This
will include server settings and a single md5 that refers to the world resource. The client
will then request the resource if it does not have it cached, and continue to request any
other resources that the first refers to if they are not in the client's cache.

Clients should send an `offset' of 0 for the first request and increase
`offset' by however much data was sent in reply. This messages may come in out
of order.

Max packet size negotiation is likely to occur during this transfer and the
server will start with MaxMessageLen messages.

Each MsgGetWorld reply includes the number of bytes left after the returned
block of data in `remaining'.  The server returns 0 in `remaining' when there
is no more data left to read.

No other messages should be returned by the server as long as the client sends
only MsgGetWorld or MsgGetResource requests. Note that the transport layer beneath may well be
sending other packets back and forth for packet size and throttling negotiation
if appropirate

getting resources used in the world
--------------------------------

  -->   MsgGetResource
	u16 length = 2
	u16 FIXME
	u32 offset
	u128 resource identifier md5
  <--   MsgGetResource
	u16 length
	u16 FIXME
	u32 offset
	u32 remaining
	u128 resource identifier md5
	... data

join game
---------
Once connected a player normally requests to join the game.  The server replies with
MsgSuperKill, MsgReject, or MsgAccept.

  -->   MsgEnter - FIXME - likely xml data? any others?
	u16 length
	u16 0x656e
	u8 team
	u8 type
	... password
	... callsign
	... email
	... avatar

  <--   MsgAccept
	u16 length
	u16 0x6163
	u8	playerid

	or

	MsgReject
	u16 length
	u16 0x726a
	u8 reason
	... reason in text

MsgEnter can also be called during a game to change player info. The server may
reject changes. The player should revert to previous data if the change is denied.

`Type' is one of the enumerants in PlayerType and `team' is one
from TeamColor. The call sign is the player's `handle' during the game;  the
call sign is used to identify the player. The server prevents duplication of
call signs during a game.  The email address can be anything, but should be the
email address for human players (e.g. user@example.com). BZFlag players can
choose not to provide an email address. The server can choose reject them if
they do not.

If the server responds with MsgReject, the client has not joined the
game but may keep the PlayerID and try again.  The reason for rejection
is included with the MsgReject message:

	RejectBadRequest        -- bogus data in MsgEnter
	RejectNeedUserAuth      -- this username requires authentication FIXME
	RejectNeedServerAuth    -- this server requires authentication FIXME
	RejectBadTeam           -- invalid team id
	RejectBadType           -- invalid client type
	RejectNoRogues          -- rogue team requested but rogues not allowed
	RejectTeamFull          -- no more players allowed on team
	RejectServerFull        -- no more players allowed on any team

If the server responds with MsgAccept, the player has successfully joined the game.
The server then sends updates about each flag, team, and other players.  The
client should be prepared to accept these updates in any order.  The flag and team
updates are sent as MsgFlagUpdate and MsgTeamUpdate messages, respectively.  Player
updates are sent as MsgAddPlayer messages.  The client will receive a MsgAddPlayer
for the player it just added, but only after it has received a MsgAddPlayer for each
of the players already joined.

Until it receives the MsgAddPlayer for its PlayerID, the client will
only receive the following kinds of messages:

	MsgSuperKill
	MsgFlagUpdate
	MsgTeamUpdate
	MsgAddPlayer

leave game
----------

Once entered, a player can leave the game at any time.  This should be done by sending
the following message then closing the connection:

  -->   MsgExit
	u16 length = 0
	u16 0x6578

There is no reply.  Clients can also leave by simply not sending any more
messages, but sending MsgExit first is recommended. The transport layer
on the server by timeout or some other method will determine the player has
left and remove them from the game.


during a game
-------------

There are several types of messages that are delivered at any time after a
player enters a game.  Clients must be prepared to handle them in any order.

  <--   MsgRemovePlayer
	u16 length = 1
	u16 0x7270
	u8 playerid

Sent when another player leaves the game by MsgExit or some other reason on the
server.

  <--   MsgTimeLeft
	u16 length = 2
	u16 0x746f
	u16 time left

Gives the time remaining in the game.  This message is only sent when the
server has time limit configured.  If the time remaining is zero, the client
should indicate to the player that the game is over.

`Time left' is in seconds.  It is not sent every second so clients will need to
do their own count down between messages.

  <--   MsgScoreOver
	u16 length = 2
	u16 0x736f
	u8 player/team id

Gives the player or team that won the game by reaching the target score. This
message is only sent when the server has a target score configured. The client
should indicate which team or player won and that the game is over.

  <--   MsgAddPlayer - FIXME xml?
	u16 length
	u16 0x6170
	u8 playerid
	u8 type
	u8 team
	u16 wins
	u16 losses
	... call sign
	... email null
	... avatar name

Sent when another player enters the game and when joining a game if other
players are already joined.  `Type' is enumerated in PlayerType, `team' is
enumerated in TeamColor.  `Wins' and `losses' give the player's score. The
player's score equals wins minus losses. `Call sign' and `email address' are
NUL terminated ASCII strings. This can also be sent by a player to change
information.

  <--   MsgFlagUpdate
	u16 length
	u16 0x6675
	u16 - flag num
	u16 - flag id
	u8 - status
	u8 - owner
	u32 - position x
	u32 - position y
	u32 - position z

Sent when a flag's state changes.  Also sent to a client when it enters a game.
`Flag num' is the index of the flag.  Flags are indexed from zero up to the
maximum number of flags minus one.

Clients must update the flag positions while the flag is in flight (i.e.
`status' is FlagInAir, FlagComing, or FlagGoing.  If FlagInAir or FlagComing
then the client should change the flag's status to FlagOnGround when the flag
reaches landing position. If FlagGoing, the client should change the flag's
status to FlagNoExist after a normal exit animation.

  <--   MsgTeamUpdate
	u16 length
	u16 0x746f
	u8 team
	u16 wins
	u16 losses

Gives the current state of team `team.'  Size is of the team is determined by
scanning the player list. team.  `Active' is the number of active players on
the team. `Wins' and `losses' give the team's score (wins minus losses).

  -->   MsgAlive
	u16 length
	u16 0x616c

A player sends this message to enter the game board.  Note that this version of
the message differs from the one sent by the server in that it lacks the player
id (which is implicit in the server connection) and position. Players must send
this message to change their state from dead to alive. Players should not send
MsgAlive for a certain penalty period after being killed (but the server might
not enforce a minimum time).  The currently penalty is ExplodeTime.

  <--   MsgAlive
	u16 length
	u16 0x616c
	u8 player id
	u32 position x
	u32 position y
	u32 position z

Sent when a player comes alive.  A player that has joined is not on the game
board until this message which gives the starting position and orientation.
Players are removed from the game board when killed and do not reappear until
sending this message again.

`Position' gives the location of the player and `forward' gives the player's
forward direction vector.


  -->   MsgKilled
  <--   u16 length
	u16 0x6b6c
	u8 victim player id
	u8 killer player id
	u8 flag id
	u8 shot id

Sent by the victim when it detects that it's been hit, naming the killer and
which of the killer's shots was the one that hit.  Note that the server might
not verify kills in any way so it might be trivial to `cheat' by claiming
you've been killed;  this is generally unproductive.  It also might be easy to
cheat by never sending MsgKilled, making you almost immortal.  Don't do this.
Note that the server ignores the victim id and inserts the sending player id.

Sent by the server when a player is killed by itself or another player. The
victim id is the player that was destroyed and the killer id is the player
credited with the kill.  Shot id identifies which of the killer's shots hit the
victim;  if the shot isn't a laser or shockwave, other players may assume the
shot has stopped and needn't check themselves against the shot (there will be no
MsgShotEnd).

  -->   MsgGrabFlag
	u16 length
	u16 0x6766
	u16 flag num

Sent by a player when it wants to grab a flag.  Players should only send this
message when their tank is within FlagRadius of a flag (that's any part of the
tank, not simply the center) and on a surface.  The server might not verify
this, but it will verify some other stuff.  The player must not assume it will
be able to grab the flag.  Instead it has to wait for a MsgGrabFlag reply.

  <--   MsgGrabFlag
	u16 length
	u16 0x6766
	u16 flag num
	u16 flag id
	u8 status
	u8 player id
	u32 position x
	u32 position y
	u32 position z

Sent by the server when a player is allowed to grab a flag.  This is both the
notice to the player trying to grab the flag that it succeeded and the notice
to all other players that the flag was grabbed.

  -->   MsgDropFlag
	u16 length
	u16 0x6466
	u8 reason

Sent by a player when it wants to drop a flag.  Players should only send this
message when they have a flag and only when the flag dropping constraints have
been met (i.e. the flag can be dropped at any time, or the player got the
antidote flag, etc.)  The player must not assume it has dropped the flag until
it receives a MsgDropFlag in response.

A player should send a DropReasonCaptured message only when 1) its tank is at
least halfway inside a team base, 2) the tank is on the base surface, and 3)
the player has its own team flag in an enemy base or the player has another
team's flag in its own base.  Note that the server might not enforce any of
these requirements.

  <--   MsgDropFlag
	u16 length
	u16 0x6466
	u8 reason
	u16 flag num
	u16 flag id
	u8 status
	u8 dropper player id
	u32 position x
	u32 position y
	u32 position z

Sent by the server when a player is allowed to drop a flag.  This is both the
notice to the player trying to drop the flag that it succeeded and the notice
to all other players that the flag was dropped.  Note that the player who
captures a flag may be on the team that was captured.

The launch point for flag drop animation is determined by the position of the
player. The player should insure that is has sent a position update for it's
current position.

"Reason" is one of:

	DropReasonTimeout
	DropReasonScore
	DropReasonCaptured
	DropReasonDropped
	DropReasonKilled

Where timeout and score are reasons for dropping a bad flag. "captured" for a
team flag. "dropped" for good or team flag. "killed" for any.

A DropReasonCaptured implies a MsgKilled for each player on the team who's flag
was captured. The server makes all players on the captured team dead.  This
message is the only notice that the players are now dead so clients should act
accordingly.

  -->   MsgShotBegin
  <--   u16 length
	u16 0x7362
	u8 shooter player id
	u8 shot id
	u32 position x
	u32 position y
	u32 position z
	u32 velocity x
	u32 velocity y
	u32 velocity z
	u32 time
	u32 lifetime
	u8 flag id

Sent by a player when it fires a shot. The identical message is sent by the
server when a player has fired a shot. The server may not verify that the
player is allowed to fire the shot. The server ignores and overwrites shooter.

`Shooter id' identifies the player that did the shooting.  `Shot id' is a
number that uniquely identifies to the shooter which shot this is. `Position' is
the starting position of the shot.  `Velocity' is the starting velocity of the
shot.  `Time' is the time the shot has existed (probably 0.0).  `Lifetime' is
how long the shot exists.  `Flag id' is a FlagId and is the type of flag the
shooter had when the shot was fired.

Clients are expected to compute the flight path of shots (except Guided
Missiles) given the information in MsgShotBegin.  That includes handling
ricochets, building impacts, and teleportation, but not tank impacts. Each
player decides if it itself has been hit by a shot at each time step based on
this flight path.  Since the path of a guided missile cannot be predicted,
updates to a guided missile's path is sent throughout its flight by the shooter
via MsgShotUpdate messages. Maring these updates, the shot path should be computed
as a normal shot.

A player should test itself against a shot using whatever algorithm it likes,
but at a minimum should test the line segments the shot moves along during the
time step against a tank aligned bounding box. Accounting for the linear motion
of the tank over the time step is better and accounting for both the linear and
angular motion is better still.  Note that the shot has a certain radius that
should be taking into account during intersection testing.  This is
particularly important when testing against a tank with the narrow flag.
Ideally, the shot would be exactly tested against the tank geometry.  However,
that's more work than realistically necessary.

  -->   MsgShotEnd
  <--   u16 length
	u16 0x7365
	u8 shooter player id
	u8 shot id
	u8 reason
	
Sent to elminate one of a player's shots. Sent by the server when a shot has
been terminated before its lifetime has expired. This message is only sent by
the player that fired a guided missile when the shot hits the ground or a
building (note that guided missiles don't ricochet).

`Shooter id' identifies the player that fired the shot and `shot id' is the
same as in the MsgShotBegin message for the shot.  `Reason' is one players
should show an explosion for the shot and zero otherwise.

The server ignores and overwrites shooter.

  -->   MsgScore
  <--   u16 length
	u16 0x7363
	u8 player id
	u16 wins
	u16 losses

Sent by a player to request a score change. The player must wait for the server
MsgScore before updating the displayed score. The server ignores and overwrites
player id.

Sent by the server when a player's score changes.  `Player id' is the player
with the new score, and `wins' and `losses' are the new scores.

  -->   MsgTeleport
  <--   u16 length
	u16 0x7363
	u8 player id
	u16 from
	u16 to

Sent by a player when it passes through a teleporter. FIXME - should player
wait for confirmation? would be laggy, but would allow the server to "lock
doors". The server ignores and overwrites player id.

Sent by the server when a player teleports.  `From' is the index of the
teleporter face the player entered and `to' is the index of the face the player
exited.

  -->   MsgMessage
  <--   u16 length
	u16 0x6d67
	u8 from player id
	u8 to player/team id
	... message

Sent by player to send a message to other players. `Player id' is the player to
receive the message (or all zeros for all players on the given team) and `team'
is the team to receive the message (or RogueTeam for all teams). The server
ignores and overwrites "from player id".

Sent by the server when one player sends a message to others. `From player id'
is the player sending the message. If `to player id' is zero then the message
is being sent to everyone on `team'.  If `to player id' is zero and `team' is
RogueTeam then the message is being sent to all players. If `to player id' is
not all zeros then `team' is ignored and the message is only for the identified
player.

  -->   MsgPlayerUpdate
  <--   u16 length
	u16 0x7075
	u8 player id
	u8 status
	u32 position x
	u32 position y
	u32 position z
	u32 velocity x
	u32 velocity y
	u32 velocity z
	u32 azimuth
	u32 angular velocity

Sent by players to notify other players of changes in its status, position, or
velocity.  The server ignores "player id" and overwrites "player id".

`Status' is the tank's current status.  See PlayerStatus for the meaning of the
bitfield's bits.  The FlagActive bit indicates whether the player's flag's
special powers are active or not.  The Phantom Zone flag is an example of a
flag that's active only some of the time. The CrossingWall bit indicates if the
player's tank is intersected by a wall or teleporter;  other players can use
this to draw the player in some special way.  CrossingWall could be computed by
each player from other information;  it's only provided to save the other
players the trouble.

`Azimuth' is the orientation of the tank in radians (the +x axis is 0.0, +y is
pi/2).  FIXME - need and int value for azimuth. `Angular velocity' is the
change in azimuth per second.  `Position' is the tank position and `velocity'
is the change in tank position per second.

A player normally only sends an update when its position or orientation as
could be predicted by other players differs from its true position or
orientation by a certain tolerance.  Other players are expected to use the last
known player data to extrapolate the current position and orientation.  This
technique is known as dead reckoning and has two primary benefits:  network
traffic is decreased since updates needn't be sent continuously and players on
systems with slower frame rates appear to move smoothly to players on systems
with faster frame rates.

Players that fail to send updates often enough should be considered to be not
responding.  Unresponsive players should be ignored until they start responding
again.

  -->   MsgShotUpdate
  <--   u16 length
	u16 0x676d
	u8 shooter id
	u8 shot id
	u32 position x
	u32 position y
	u32 position z
	u32 velocity x
	u32 velocity y
	u32 velocity z
	u32 time - FIXME this could probably be a u16
	u8 target player id

Sent by players with active guided missiles to notify other players of changes
to the motion of weapons like the guided missile.  The server may ignore the
"player id" and fill in the actual "player id".

See MsgShotBegin for the meaning of most items.  `Time' is the current
age of the shot (the time since being fired).  `Target id' is the current
target of the guided missile or zero if there is no target.

Players are expected to use dead reckoning to update the position and velocity
of shots between MsgShotUpdate messages.  Since guided missiles deviate from
their predicted course only when the target changes, these message will be
fairly rare.  Note that different players may have different ideas of where the
target is and that that may cause slightly different courses.  This is
generally not a problem.
